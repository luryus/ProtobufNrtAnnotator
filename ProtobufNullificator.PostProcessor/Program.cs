using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ProtobufNullificator.PostProcessor;

if (args.Length == 0)
{
    Console.WriteLine("Usage: ProtobufNullificator.PostProcessor <file1.cs> [file2.cs] ...");
    return 1;
}

var files = args.ToList();

Console.WriteLine("Loading and parsing files...");

// Parse all files and create syntax trees
var syntaxTrees = new List<SyntaxTree>();
var filePathToTree = new Dictionary<string, SyntaxTree>();

foreach (var filePath in files)
{
    if (!File.Exists(filePath))
    {
        Console.WriteLine($"Warning: File not found: {filePath}");
        continue;
    }

    var code = await File.ReadAllTextAsync(filePath);
    
    // Only process files that look like protobuf-generated code
    if (!code.Contains("Generated by the protocol buffer compiler"))
    {
        Console.WriteLine($"Skipping {filePath} (not protobuf-generated)");
        continue;
    }

    var tree = CSharpSyntaxTree.ParseText(code, path: filePath);
    syntaxTrees.Add(tree);
    filePathToTree[filePath] = tree;
}

if (syntaxTrees.Count == 0)
{
    Console.WriteLine("No protobuf-generated files to process.");
    return 0;
}

Console.WriteLine($"Found {syntaxTrees.Count} protobuf-generated files");

// Create a compilation with all syntax trees
// Add basic references needed for compilation
var references = new List<MetadataReference>
{
    MetadataReference.CreateFromFile(typeof(object).Assembly.Location), // System.Private.CoreLib
    MetadataReference.CreateFromFile(typeof(Console).Assembly.Location), // System.Console
};

// Try to add System.Runtime reference
var systemRuntimePath = Path.Combine(Path.GetDirectoryName(typeof(object).Assembly.Location)!, "System.Runtime.dll");
if (File.Exists(systemRuntimePath))
{
    references.Add(MetadataReference.CreateFromFile(systemRuntimePath));
}

Console.WriteLine("Processing files with nullability annotations...");

foreach (var (filePath, tree) in filePathToTree)
{
    Console.WriteLine($"Processing {filePath}...");
    var code = await File.ReadAllTextAsync(filePath);
    
    // We don't pass external references here for now, relying on basic types being enough.
    // If needed, we could parse csproj references or pass them as args.
    // For the tool usage, we might need to be smarter about references if the proto generated code 
    // depends on other user types. But for now, let's try with basic references.
    // Actually, for the tool to work correctly in the build, it might need references.
    // But let's see if the default references in NullificatorRunner are enough for standard protos.
    
    var newCode = await NullificatorRunner.ProcessContentAsync(code);

    if (newCode != null)
    {
        await File.WriteAllTextAsync(filePath, newCode);
        Console.WriteLine($"  Updated {filePath}");
    }
}

Console.WriteLine("Done!");
return 0;
