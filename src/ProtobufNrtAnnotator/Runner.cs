using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ProtobufNrtAnnotator;

internal static class Runner
{
    public static string? ProcessContent(string code)
    {
        if (!ShouldProcessFile(code))
        {
            return null;
        }

        var tree = CSharpSyntaxTree.ParseText(code);
        var root = tree.GetRoot();

        // Create compilation
        var references = new List<MetadataReference>
        {
            MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
            MetadataReference.CreateFromFile(typeof(Google.Protobuf.MessageParser).Assembly.Location),
            MetadataReference.CreateFromFile(Path.Combine(Path.GetDirectoryName(typeof(object).Assembly.Location)!, "System.Runtime.dll"))
        };

        var compilation = CSharpCompilation.Create("ProtobufNrtAnnotatorAnalysis")
            .AddReferences(references)
            .AddSyntaxTrees(tree);

        var semanticModel = compilation.GetSemanticModel(tree);

        // Step 1: Analyze the original tree to determine which properties should be nullable
        var nullabilityDecisions = NullabilityRewriter.AnalyzeTree(root, semanticModel);

        // Step 2: Rewrite the tree using the pre-computed decisions
        var rewriter = new NullabilityRewriter(nullabilityDecisions);
        var newRoot = rewriter.Visit(root);

        // Step 3: Add #nullable enable directive at the top
        if (newRoot is CompilationUnitSyntax compilationUnit)
        {
            var nullableText = "#nullable enable annotations" + Environment.NewLine;
            var nullableTree = CSharpSyntaxTree.ParseText(nullableText + "class Dummy {}");
            var nullableDirective = nullableTree.GetRoot()
                .DescendantTrivia()
                .First(t => t.IsKind(SyntaxKind.NullableDirectiveTrivia));

            var newLine = SyntaxFactory.EndOfLine(Environment.NewLine);

            var leadingTrivia = compilationUnit.GetLeadingTrivia()
                .Insert(0, newLine)
                .Insert(0, nullableDirective);
            newRoot = compilationUnit.WithLeadingTrivia(leadingTrivia);
        }

        return newRoot.ToFullString();
    }

    /// <summary>
    /// Determines whether a file should be processed by the annotator.
    /// Returns true if the file should be processed, false otherwise.
    /// </summary>
    private static bool ShouldProcessFile(string code)
    {
        // Only process files that are actually protobuf-generated
        if (!code.Contains("Generated by the protocol buffer compiler"))
        {
            return false;
        }

        // Skip gRPC service files (they don't need nullability annotations)
        if (code.Contains("System.CodeDom.Compiler.GeneratedCode(\"grpc_csharp_plugin\""))
        {
            return false;
        }

        return true;
    }
}
