using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ProtobufNrtAnnotator;

internal static class Runner
{
    private const string ToolMarker = "// Nullable annotations added by ProtobufNrtAnnotator";

    public static string? ProcessContent(string code)
    {
        if (!ShouldProcessFile(code))
        {
            return null;
        }

        var tree = CSharpSyntaxTree.ParseText(code);
        var root = tree.GetRoot();

        // Create compilation
        var references = new List<MetadataReference>
        {
            MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
            MetadataReference.CreateFromFile(typeof(Google.Protobuf.MessageParser).Assembly.Location),
            MetadataReference.CreateFromFile(Path.Combine(Path.GetDirectoryName(typeof(object).Assembly.Location)!, "System.Runtime.dll"))
        };

        var compilation = CSharpCompilation.Create("ProtobufNrtAnnotatorAnalysis")
            .AddReferences(references)
            .AddSyntaxTrees(tree);

        var semanticModel = compilation.GetSemanticModel(tree);

        // Step 1: Analyze the original tree to determine which properties should be nullable
        var nullabilityDecisions = NullabilityRewriter.AnalyzeTree(root, semanticModel);

        // Step 2: Rewrite the tree using the pre-computed decisions
        var rewriter = new NullabilityRewriter(nullabilityDecisions);
        var newRoot = rewriter.Visit(root);

        // Step 3: Add marker and nullable directive
        var markerTrivia = SyntaxFactory.Comment(ToolMarker + Environment.NewLine);
        
        var nullableText = "#nullable enable annotations" + Environment.NewLine;
        var nullableTree = CSharpSyntaxTree.ParseText(nullableText);
        var nullableDirectiveTrivia = nullableTree.GetRoot().DescendantTrivia().First(t => t.IsKind(SyntaxKind.NullableDirectiveTrivia));
        var endOfLineTrivia = SyntaxFactory.EndOfLine(Environment.NewLine);

        // Try to find the region to insert after
        var regionTrivia = newRoot.DescendantTrivia()
            .FirstOrDefault(t => t.IsKind(SyntaxKind.RegionDirectiveTrivia) && t.ToString().Contains("Designer generated code"));

        if (regionTrivia != default(SyntaxTrivia))
        {
            var token = regionTrivia.Token;
            var leadingTrivia = token.LeadingTrivia;
            var regionIndex = leadingTrivia.IndexOf(regionTrivia);
            
            // Insert after the region and its following EOL if present
            var insertIndex = regionIndex + 1;
            if (insertIndex < leadingTrivia.Count && leadingTrivia[insertIndex].IsKind(SyntaxKind.EndOfLineTrivia))
            {
                insertIndex++;
            }

            var newLeadingTrivia = leadingTrivia.Insert(insertIndex, nullableDirectiveTrivia);
            newLeadingTrivia = newLeadingTrivia.Insert(insertIndex + 1, endOfLineTrivia);
            
            newRoot = newRoot.ReplaceToken(token, token.WithLeadingTrivia(newLeadingTrivia));
        }
        else
        {
            // Fallback: Add nullable directive to top
             if (newRoot is CompilationUnitSyntax compilationUnit)
             {
                 var leading = compilationUnit.GetLeadingTrivia();
                 leading = leading.Insert(0, endOfLineTrivia);
                 leading = leading.Insert(0, nullableDirectiveTrivia);
                 newRoot = compilationUnit.WithLeadingTrivia(leading);
             }
        }

        // Always add marker to the very top
        if (newRoot is CompilationUnitSyntax cu)
        {
            var leading = cu.GetLeadingTrivia();
            leading = leading.Insert(0, markerTrivia);
            newRoot = cu.WithLeadingTrivia(leading);
        }

        return newRoot.ToFullString();
    }

    /// <summary>
    /// Determines whether a file should be processed by the annotator.
    /// Returns true if the file should be processed, false otherwise.
    /// </summary>
    private static bool ShouldProcessFile(string code)
    {
        // Only process files that are actually protobuf-generated
        if (!code.Contains("Generated by the protocol buffer compiler"))
        {
            return false;
        }

        // Skip files already processed by this tool
        if (code.Contains(ToolMarker))
        {
            return false;
        }

        // Skip gRPC service files (they don't need nullability annotations)
        if (code.Contains("System.CodeDom.Compiler.GeneratedCode(\"grpc_csharp_plugin\""))
        {
            return false;
        }

        return true;
    }
}
